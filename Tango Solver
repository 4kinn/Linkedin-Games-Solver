javascript:(function(){
    console.log("TANGO SOLVER START");
    document.querySelectorAll('.tango-hint-overlay').forEach(el => el.remove());
    const container = document.querySelector('[data-testid="tango-game-container"]');
    if (!container) return alert("Game board not found");
    const cells = Array.from(container.querySelectorAll('div[data-testid^="cell-"]'));
    const size = Math.sqrt(cells.length);
    if (!Number.isInteger(size)) return alert("Board size error");
    let grid = [], locked = [], constraints = [];
    for (let i = 0; i < size; i++) {
        grid[i] = [];
        locked[i] = [];
        for (let j = 0; j < size; j++) {
            const idx = i * size + j;
            const cell = cells[idx];
            const html = cell.innerHTML.toLowerCase();
            let val = null;
            if (html.includes('label="sun"') || html.includes('label="g√ºne≈ü"')) val = 1;
            else if (html.includes('label="moon"') || html.includes('label="ay"')) val = 0;
            const isLocked = cell.getAttribute('aria-disabled') === 'true';
            grid[i][j] = isLocked ? val : null;
            locked[i][j] = isLocked;
            const edges = cell.querySelectorAll('[data-testid*="edge"], [aria-label="Equal"], [aria-label="Cross"], [aria-label="E≈üit"], [aria-label="√áarpƒ±"]');
            if (edges.length > 0) {
                const cRect = cell.getBoundingClientRect();
                edges.forEach(edge => {
                    const eRect = edge.getBoundingClientRect();
                    let type = null;
                    const eHtml = edge.outerHTML.toLowerCase();
                    if (eHtml.includes('equal') || eHtml.includes('e≈üit')) type = 'EQUAL';
                    else if (eHtml.includes('cross') || eHtml.includes('√ßarpƒ±')) type = 'OPPOSITE';
                    if (type) {
                        const cx = cRect.left + cRect.width / 2;
                        const cy = cRect.top + cRect.height / 2;
                        const ex = eRect.left + eRect.width / 2;
                        const ey = eRect.top + eRect.height / 2;
                        if (ex > cx + (cRect.width * 0.3) && j < size - 1) constraints.push({ r1: i, c1: j, r2: i, c2: j + 1, type: type });
                        if (ey > cy + (cRect.height * 0.3) && i < size - 1) constraints.push({ r1: i, c1: j, r2: i + 1, c2: j, type: type });
                    }
                });
            }
        }
    }
    function isUnique(b) {
        const rows = b.map(row => row.join(''));
        if (new Set(rows).size !== size) return false;
        const cols = [];
        for (let j = 0; j < size; j++) {
            let col = "";
            for (let i = 0; i < size; i++) col += b[i][j];
            cols.push(col);
        }
        if (new Set(cols).size !== size) return false;
        return true;
    }
    function isValid(b, r, c, n) {
        if (c >= 2 && b[r][c - 1] === n && b[r][c - 2] === n) return false;
        if (r >= 2 && b[r - 1][c] === n && b[r - 2][c] === n) return false;
        let rc = 0;
        for (let k = 0; k < c; k++) if (b[r][k] === n) rc++;
        if (n === b[r][c]) rc++;
        if (rc > size / 2) return false;
        let cc = 0;
        for (let k = 0; k < r; k++) if (b[k][c] === n) cc++;
        if (cc > size / 2) return false;
        for (let cons of constraints) {
            let v1 = b[cons.r1][cons.c1];
            let v2 = b[cons.r2][cons.c2];
            if (v1 !== null && v2 !== null) {
                if (cons.type === 'EQUAL' && v1 !== v2) return false;
                if (cons.type === 'OPPOSITE' && v1 === v2) return false;
            }
        }
        return true;
    }
    function solve(b, r, c) {
        if (r === size) return isUnique(b);
        let nr = c === size - 1 ? r + 1 : r;
        let nc = c === size - 1 ? 0 : c + 1;
        if (b[r][c] !== null) return solve(b, nr, nc);
        for (let n of [0, 1]) {
            b[r][c] = n;
            if (isValid(b, r, c, n)) {
                if (solve(b, nr, nc)) return true;
            }
            b[r][c] = null;
        }
        return false;
    }
    if (solve(grid, 0, 0)) {
        cells.forEach((cell, idx) => {
            const r = Math.floor(idx / size);
            const c = idx % size;
            if (!locked[r][c]) {
                const val = grid[r][c];
                const overlay = document.createElement('div');
                overlay.className = 'tango-hint-overlay';
                overlay.innerText = val === 1 ? '‚òÄÔ∏è' : 'üåô';
                Object.assign(overlay.style, {
                    position: 'absolute', top: '0', left: '0', width: '100%', height: '100%',
                    pointerEvents: 'none', zIndex: '9999', display: 'flex', alignItems: 'center',
                    justifyContent: 'center', fontSize: '36px', color: val === 1 ? '#ff9900' : '#3366ff',
                    textShadow: '0 0 5px white', opacity: '0.8'
                });
                if (getComputedStyle(cell).position === 'static') cell.style.position = 'relative';
                cell.appendChild(overlay);
            }
        });
    } else {
        alert("Solution not found");
    }
})();
